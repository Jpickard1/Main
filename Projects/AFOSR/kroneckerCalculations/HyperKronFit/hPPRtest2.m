function [llDiff] = hPPRtest2(p, theta, A, u, v)
% HPPRTEST2
%
%   This function evaluates equations 5.7 and 5.8 in the thesis to
%   determine if the likelihood of the adjacency matrix being generated by
%   A will increase or decrease when the labeling of As nodes is evaluated
%   with permutations p and p with the terms u and v swapped.
%
%   1. Make permutations p1 and p2
%   2. Evaluate likelihoods of rows i and j of A assuming no edges
%   3. Make updates for existing edges
%
% Auth: Joshua Pickard
%       jpic@umich.edu
% Date: June 5, 2023

theta = theta / sum(sum(theta));

l1 = 0;                         % Likelihood of permutation 1
l2 = 0;                         % Likelihood of permutation 2

K = length(size(A));            % order of uniform hypergraph
n = size(A,1);                  % number of vertices in A
n0 = size(theta,1);             % size of initiator matrix
kronExp = log(n) / log(n0);     % number of repeated kron(theta, theta) until
                                % it is the size of A

theta2 = theta .^ 2;            % squares every element of theta
thetaR = sum(theta, 2);         % row sum of theta
thetaC = sum(theta, 1);         % column sum of theta
theta2R = sum(theta2, 2);       % row sum of theta squared
theta2C = sum(theta2, 1);       % colum sum of theta squared


%   1. Make permutations p1 and p2
p1 = p;                 % permutation 1
p2 = p;
p2([u v]) = p2([v u]);  % permutation 2

%   2. Evaluate likelihoods of rows i and j of A assuming no edges
%       2.a Evaluate p1 first
p1u = p1(u);
p1v = p1(v);
p1uK = kronIndices(p1u, n, n0);
p1vK = kronIndices(p1v, n, n0);
llP1uR = - (sum(prod(thetaR(p1uK)))) - 0.5 * (sum(prod(theta2R(p1uK))));
llP1uC = - (sum(prod(thetaC(p1uK)))) - 0.5 * (sum(prod(theta2C(p1uK))));
llP1vR = - (sum(prod(thetaR(p1vK)))) - 0.5 * (sum(prod(theta2R(p1vK))));
llP1vC = - (sum(prod(thetaC(p1vK)))) - 0.5 * (sum(prod(theta2C(p1vK))));
% llP1uR = - (sum(thetaR(p1uK)))^kronExp - 0.5 * (sum(theta2R(p1uK))^kronExp);
% llP1uC = - (sum(thetaC(p1uK)))^kronExp - 0.5 * (sum(theta2C(p1uK))^kronExp);
% llP1vR = - (sum(thetaR(p1vK)))^kronExp - 0.5 * (sum(theta2R(p1vK))^kronExp);
% llP1vC = - (sum(thetaC(p1vK)))^kronExp - 0.5 * (sum(theta2C(p1vK))^kronExp);
l1 = l1 + llP1uR + llP1uC + llP1vR + llP1vC;

%           update for duplicate edges
l1 = l1 + log(1 - exp(edgeLLapx(n, theta, p1(u), p1(u)))) + ...
          log(1 - exp(edgeLLapx(n, theta, p1(u), p1(v)))) + ...
          log(1 - exp(edgeLLapx(n, theta, p1(v), p1(u)))) + ...
          log(1 - exp(edgeLLapx(n, theta, p1(v), p1(v))));

%       2.a Evaluate p2 first
p2u = p2(u);
p2v = p2(v);
p2uK = kronIndices(p2u, n, n0);
p2vK = kronIndices(p2v, n, n0);
llP2uR = - (sum(prod(thetaR(p2uK)))) - 0.5 * (sum(prod(theta2R(p2uK))));
llP2uC = - (sum(prod(thetaC(p2uK)))) - 0.5 * (sum(prod(theta2C(p2uK))));
llP2vR = - (sum(prod(thetaR(p2vK)))) - 0.5 * (sum(prod(theta2R(p2vK))));
llP2vC = - (sum(prod(thetaC(p2vK)))) - 0.5 * (sum(prod(theta2C(p2vK))));
l2 = l2 + llP2uR + llP2uC + llP2vR + llP2vC;

%           update for duplicate edges
%           update for duplicate edges
l2 = l2 + log(1 - exp(edgeLLapx(n, theta, p2(u), p2(u)))) + ...
          log(1 - exp(edgeLLapx(n, theta, p2(u), p2(v)))) + ...
          log(1 - exp(edgeLLapx(n, theta, p2(v), p2(u)))) + ...
          log(1 - exp(edgeLLapx(n, theta, p2(v), p2(v))));

%   3. Make updates for existing edges
% update column u
idxs = find(A(:,u) == 1);
for i=1:length(idxs)
    j = idxs(i);
    eLLp1 = edgeLLapx(n, theta, p1(j), p1(u));
    eLLp2 = edgeLLapx(n, theta, p2(j), p2(u));

    ll1update = -log(1-exp(eLLp1)) + eLLp1;
    ll2update = -log(1-exp(eLLp2)) + eLLp2;

    l1 = l1 + ll1update;
    l2 = l2 + ll2update;
end

% update column v
idxs = find(A(:,v) == 1);
for i=1:length(idxs)
    j = idxs(i);
    eLLp1 = edgeLLapx(n, theta, p1(j), p1(v));
    eLLp2 = edgeLLapx(n, theta, p2(j), p2(v));

    ll1update = -log(1-exp(eLLp1)) + eLLp1;
    ll2update = -log(1-exp(eLLp2)) + eLLp2;

    l1 = l1 + ll1update;
    l2 = l2 + ll2update;
end

% update row u
idxs = find(A(u,:) == 1);
for i=1:length(idxs)
    j = idxs(i);
    eLLp1 = edgeLLapx(n, theta, p1(u), p1(j));
    eLLp2 = edgeLLapx(n, theta, p2(u), p2(j));

    ll1update = -log(1-exp(eLLp1)) + eLLp1;
    ll2update = -log(1-exp(eLLp2)) + eLLp2;

    l1 = l1 + ll1update;
    l2 = l2 + ll2update;
end

% update row v
idxs = find(A(v,:) == 1);
for i=1:length(idxs)
    j = idxs(i);
    eLLp1 = edgeLLapx(n, theta, p1(v), p1(j));
    eLLp2 = edgeLLapx(n, theta, p2(v), p2(j));

    ll1update = -log(1-exp(eLLp1)) + eLLp1;
    ll2update = -log(1-exp(eLLp2)) + eLLp2;

    l1 = l1 + ll1update;
    l2 = l2 + ll2update;
end

% r = exp(l1) / exp(l2);
llDiff = l2 - l1;

end


% r = 1;
% for i=1:n
%     e1 = edgeProbability(n, theta, p1(u), p1(i));
%     e2 = edgeProbability(n, theta, p2(u), p2(i));
%     if A(u,i) == 1
%         rij = e1 / e2;
%     else
%         rij = (1 - e1) / (1 - e2);
%     end
%     r = r * (rij);
% 
%     e1 = edgeProbability(n, theta, p1(i), p1(u));
%     e2 = edgeProbability(n, theta, p2(i), p2(u));
%     if A(i,u) == 1
%         rij = e1 / e2;
%     else
%         rij = (1 - e1) / (1 - e2);
%     end
%     r = r * (rij);
% 
%     e1 = edgeProbability(n, theta, p1(v), p1(i));
%     e2 = edgeProbability(n, theta, p2(v), p2(i));
%     if A(v,i) == 1
%         rij = e1 / e2;
%     else
%         rij = (1 - e1) / (1 - e2);
%     end
%     r = r * (rij);
% 
%     e1 = edgeProbability(n, theta, p1(i), p1(v));
%     e2 = edgeProbability(n, theta, p2(i), p2(v));
%     if A(i,v) == 1
%         rij = e1 / e2;
%     else
%         rij = (1 - e1) / (1 - e2);
%     end
%     r = r * (rij);
% end